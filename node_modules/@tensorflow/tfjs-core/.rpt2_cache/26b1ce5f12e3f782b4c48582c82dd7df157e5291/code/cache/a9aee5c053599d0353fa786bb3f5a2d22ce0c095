{"code":"import * as broadcast_util from '../../ops/broadcast_util';\r\nvar CHECK_NAN_SNIPPET = \"\\n  if (isNaN(a)) return a;\\n  if (isNaN(b)) return b;\\n\";\r\nexport var ADD = 'return a + b;';\r\nexport var SUB = 'return a - b;';\r\nexport var MUL = 'return a * b;';\r\nexport var DIV = 'return a / b;';\r\nexport var INT_DIV = \"\\n  float resultSign = sign(a) * sign(b);\\n  int ia = round(a);\\n  int ib = round(b);\\n  int result = ia / ib;\\n  int amodb = ia - ib * result;\\n\\n  if (resultSign < 0.0 && amodb != 0) {\\n    result -= 1;\\n  }\\n  return float(result);\\n\";\r\nexport var POW = \"\\n  return (round(mod(b, 2.0)) == 0 || round(mod(b, 2.0)) == 2) ?\\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\\n\";\r\nexport var SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';\r\nexport var EQUAL = \"return float(a == b);\";\r\nexport var NOT_EQUAL = \"return float(a != b);\";\r\nexport var LESS = \"return float(a < b);\";\r\nexport var LESS_EQUAL = \"return float(a <= b);\";\r\nexport var GREATER = \"return float(a > b);\";\r\nexport var GREATER_EQUAL = \"return float(a >= b);\";\r\nexport var LOGICAL_AND = \"return float(a >= 1.0 && b >= 1.0);\";\r\nexport var LOGICAL_OR = \"return float(a >= 1.0 || b >= 1.0);\";\r\nexport var MAX = CHECK_NAN_SNIPPET + \"\\n  return max(a, b);\\n\";\r\nexport var MIN = CHECK_NAN_SNIPPET + \"\\n  return min(a, b);\\n\";\r\nexport var MOD = \"return mod(a, b);\";\r\nexport var ATAN2 = CHECK_NAN_SNIPPET + \"\\n  return atan(a, b);\\n\";\r\nexport var ELU_DER = \"return (b >= 1.0) ? a : a * (b + 1.0);\";\r\nvar BinaryOpProgram = (function () {\r\n    function BinaryOpProgram(op, aShape, bShape) {\r\n        this.variableNames = ['A', 'B'];\r\n        this.supportsBroadcasting = true;\r\n        this.outputShape =\r\n            broadcast_util.assertAndGetBroadcastShape(aShape, bShape);\r\n        this.userCode = \"\\n      float binaryOperation(float a, float b) {\\n        \" + op + \"\\n      }\\n\\n      void main() {\\n        float a = getAAtOutCoords();\\n        float b = getBAtOutCoords();\\n        setOutput(binaryOperation(a, b));\\n      }\\n    \";\r\n    }\r\n    return BinaryOpProgram;\r\n}());\r\nexport { BinaryOpProgram };\r\n//# sourceMappingURL=binaryop_gpu.js.map","map":"{\"version\":3,\"file\":\"binaryop_gpu.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/kernels/webgl/binaryop_gpu.ts\"],\"names\":[],\"mappings\":\"AAiBA,OAAO,KAAK,cAAc,MAAM,0BAA0B,CAAC;AAG3D,IAAM,iBAAiB,GAAG,0DAGzB,CAAC;AAEF,MAAM,CAAC,IAAM,GAAG,GAAG,eAAe,CAAC;AACnC,MAAM,CAAC,IAAM,GAAG,GAAG,eAAe,CAAC;AACnC,MAAM,CAAC,IAAM,GAAG,GAAG,eAAe,CAAC;AACnC,MAAM,CAAC,IAAM,GAAG,GAAG,eAAe,CAAC;AAMnC,MAAM,CAAC,IAAM,OAAO,GAAG,8OAWtB,CAAC;AAEF,MAAM,CAAC,IAAM,GAAG,GAAG,uHAGlB,CAAC;AACF,MAAM,CAAC,IAAM,kBAAkB,GAAG,2BAA2B,CAAC;AAE9D,MAAM,CAAC,IAAM,KAAK,GAAG,uBAAuB,CAAC;AAE7C,MAAM,CAAC,IAAM,SAAS,GAAG,uBAAuB,CAAC;AAEjD,MAAM,CAAC,IAAM,IAAI,GAAG,sBAAsB,CAAC;AAE3C,MAAM,CAAC,IAAM,UAAU,GAAG,uBAAuB,CAAC;AAElD,MAAM,CAAC,IAAM,OAAO,GAAG,sBAAsB,CAAC;AAE9C,MAAM,CAAC,IAAM,aAAa,GAAG,uBAAuB,CAAC;AAErD,MAAM,CAAC,IAAM,WAAW,GAAG,qCAAqC,CAAC;AAEjE,MAAM,CAAC,IAAM,UAAU,GAAG,qCAAqC,CAAC;AAEhE,MAAM,CAAC,IAAM,GAAG,GAAG,iBAAiB,GAAG,yBAEtC,CAAC;AACF,MAAM,CAAC,IAAM,GAAG,GAAG,iBAAiB,GAAG,yBAEtC,CAAC;AACF,MAAM,CAAC,IAAM,GAAG,GAAG,mBAAmB,CAAC;AAEvC,MAAM,CAAC,IAAM,KAAK,GAAG,iBAAiB,GAAG,0BAExC,CAAC;AAEF,MAAM,CAAC,IAAM,OAAO,GAAG,wCAAwC,CAAC;AAEhE;IAME,yBAAY,EAAU,EAAE,MAAgB,EAAE,MAAgB;QAL1D,kBAAa,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;QAG3B,yBAAoB,GAAG,IAAI,CAAC;QAG1B,IAAI,CAAC,WAAW;YACZ,cAAc,CAAC,0BAA0B,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;QAC9D,IAAI,CAAC,QAAQ,GAAG,gEAEV,EAAE,2KAQP,CAAC;IACJ,CAAC;IACH,sBAAC;AAAD,CAAC,AArBD,IAqBC\"}","dts":{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/rollup/tfjs-core/kernels/webgl/binaryop_gpu.d.ts","text":"import { GPGPUProgram } from './gpgpu_math';\r\nexport declare const ADD = \"return a + b;\";\r\nexport declare const SUB = \"return a - b;\";\r\nexport declare const MUL = \"return a * b;\";\r\nexport declare const DIV = \"return a / b;\";\r\nexport declare const INT_DIV = \"\\n  float resultSign = sign(a) * sign(b);\\n  int ia = round(a);\\n  int ib = round(b);\\n  int result = ia / ib;\\n  int amodb = ia - ib * result;\\n\\n  if (resultSign < 0.0 && amodb != 0) {\\n    result -= 1;\\n  }\\n  return float(result);\\n\";\r\nexport declare const POW = \"\\n  return (round(mod(b, 2.0)) == 0 || round(mod(b, 2.0)) == 2) ?\\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\\n\";\r\nexport declare const SQUARED_DIFFERENCE = \"return (a - b) * (a - b);\";\r\nexport declare const EQUAL = \"return float(a == b);\";\r\nexport declare const NOT_EQUAL = \"return float(a != b);\";\r\nexport declare const LESS = \"return float(a < b);\";\r\nexport declare const LESS_EQUAL = \"return float(a <= b);\";\r\nexport declare const GREATER = \"return float(a > b);\";\r\nexport declare const GREATER_EQUAL = \"return float(a >= b);\";\r\nexport declare const LOGICAL_AND = \"return float(a >= 1.0 && b >= 1.0);\";\r\nexport declare const LOGICAL_OR = \"return float(a >= 1.0 || b >= 1.0);\";\r\nexport declare const MAX: string;\r\nexport declare const MIN: string;\r\nexport declare const MOD = \"return mod(a, b);\";\r\nexport declare const ATAN2: string;\r\nexport declare const ELU_DER = \"return (b >= 1.0) ? a : a * (b + 1.0);\";\r\nexport declare class BinaryOpProgram implements GPGPUProgram {\r\n    variableNames: string[];\r\n    outputShape: number[];\r\n    userCode: string;\r\n    supportsBroadcasting: boolean;\r\n    constructor(op: string, aShape: number[], bShape: number[]);\r\n}\r\n"}}
