{"code":"var Pool2DProgram = (function () {\r\n    function Pool2DProgram(convInfo, poolType, computePositions) {\r\n        this.variableNames = ['x'];\r\n        if (poolType === 'avg' && computePositions) {\r\n            throw new Error('Cannot compute positions for average pool.');\r\n        }\r\n        var filterHeight = convInfo.filterHeight;\r\n        var filterWidth = convInfo.filterWidth;\r\n        var strideHeight = convInfo.strideHeight;\r\n        var strideWidth = convInfo.strideWidth;\r\n        var padTop = convInfo.padInfo.top;\r\n        var padLeft = convInfo.padInfo.left;\r\n        this.outputShape = convInfo.outShape;\r\n        var isAvgPool = poolType === 'avg';\r\n        var initializationValue = '0.0';\r\n        if (!isAvgPool) {\r\n            initializationValue = '-1.0 / 0.0';\r\n        }\r\n        if (computePositions) {\r\n            var compareOp_1 = '>=';\r\n            this.userCode = \"\\n        const ivec2 strides = ivec2(\" + strideHeight + \", \" + strideWidth + \");\\n        const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n\\n        void main() {\\n          ivec4 coords = getOutputCoords();\\n          int batch = coords[0];\\n          int d = coords[3];\\n\\n          ivec2 xRCCorner = coords.yz * strides - pads;\\n          int xRCorner = xRCCorner.x;\\n          int xCCorner = xRCCorner.y;\\n\\n          // max/min x(?, ?, d) to get y(yR, yC, d).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n          float avgValue = 0.0;\\n\\n          for (int wR = 0; wR < \" + filterHeight + \"; wR++) {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \" + convInfo.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \" + filterWidth + \"; wC++) {\\n              int xC = xCCorner + wC;\\n\\n              if (xC < 0 || xC >= \" + convInfo.inWidth + \") {\\n                continue;\\n              }\\n\\n              float value = getX(batch, xR, xC, d);\\n\\n              // If a min / max value has already been found, use it. If not,\\n              // use the current value.\\n              float currMinMaxValue = mix(\\n                  value, minMaxValue, minMaxValueFound);\\n              if (value \" + compareOp_1 + \" currMinMaxValue) {\\n                minMaxValue = value;\\n                minMaxValueFound = 1.0;\\n                minMaxPosition = wR * \" + filterWidth + \" + wC;\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \";\r\n            return;\r\n        }\r\n        var compareOp = 'max';\r\n        var returnValue = poolType + \"(\" + poolType + \"(\" + poolType + \"(\" +\r\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\r\n        if (poolType === 'avg') {\r\n            returnValue = \"avgValue / count\";\r\n        }\r\n        var filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\r\n        var filterWidthVec4Remainder = filterWidth % 4;\r\n        var updateSnippet = \"\\n      if (\" + isAvgPool + \") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = \" + compareOp + \"(values, minMaxValue);\\n      }\\n    \";\r\n        this.userCode = \"\\n      const ivec2 strides = ivec2(\" + strideHeight + \", \" + strideWidth + \");\\n      const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n      const float initializationValue = \" + initializationValue + \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float count = 0.0;\\n\\n      float getValue(int batch, int xR, int xC, int d) {\\n        if (xC < 0 || xC >= \" + convInfo.inWidth + \") {\\n          return initializationValue;\\n        }\\n        count += 1.0;\\n        return getX(batch, xR, xC, d);\\n      }\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // max/min x(?, ?, d) to get y(yR, yC, d).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\" + initializationValue + \");\\n        float avgValue = 0.0;\\n        count = 0.0;\\n\\n        for (int wR = 0; wR < \" + filterHeight + \"; wR++) {\\n          int xR = xRCorner + wR;\\n\\n          if (xR < 0 || xR >= \" + convInfo.inHeight + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + filterWidthNearestVec4 + \"; wC += 4) {\\n            int xC = xCCorner + wC;\\n\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + 1, d),\\n              getValue(batch, xR, xC + 2, d),\\n              getValue(batch, xR, xC + 3, d)\\n            );\\n\\n            \" + updateSnippet + \"\\n          }\\n\\n          int xC = xCCorner + \" + filterWidthNearestVec4 + \";\\n          if (\" + (filterWidthVec4Remainder === 1) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              initializationValue,\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \" + updateSnippet + \"\\n          } else if (\" + (filterWidthVec4Remainder === 2) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + 1, d),\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \" + updateSnippet + \"\\n          } else if (\" + (filterWidthVec4Remainder === 3) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + 1, d),\\n              getValue(batch, xR, xC + 2, d),\\n              initializationValue\\n            );\\n\\n            \" + updateSnippet + \"\\n          }\\n        }\\n        setOutput(\" + returnValue + \");\\n      }\\n    \";\r\n    }\r\n    return Pool2DProgram;\r\n}());\r\nexport { Pool2DProgram };\r\n//# sourceMappingURL=pool_gpu.js.map","map":"{\"version\":3,\"file\":\"pool_gpu.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/kernels/webgl/pool_gpu.ts\"],\"names\":[],\"mappings\":\"AAoBA;IAKE,uBACI,QAAoB,EAAE,QAAqB,EAAE,gBAAyB;QAL1E,kBAAa,GAAG,CAAC,GAAG,CAAC,CAAC;QAMpB,EAAE,CAAC,CAAC,QAAQ,KAAK,KAAK,IAAI,gBAAgB,CAAC,CAAC,CAAC;YAC3C,MAAM,IAAI,KAAK,CAAC,4CAA4C,CAAC,CAAC;QAChE,CAAC;QAED,IAAM,YAAY,GAAG,QAAQ,CAAC,YAAY,CAAC;QAC3C,IAAM,WAAW,GAAG,QAAQ,CAAC,WAAW,CAAC;QACzC,IAAM,YAAY,GAAG,QAAQ,CAAC,YAAY,CAAC;QAC3C,IAAM,WAAW,GAAG,QAAQ,CAAC,WAAW,CAAC;QACzC,IAAM,MAAM,GAAG,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC;QACpC,IAAM,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC;QACtC,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAC,QAAQ,CAAC;QAErC,IAAM,SAAS,GAAG,QAAQ,KAAK,KAAK,CAAC;QAErC,IAAI,mBAAmB,GAAG,KAAK,CAAC;QAChC,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;YACf,mBAAmB,GAAG,YAAY,CAAC;QACrC,CAAC;QAED,EAAE,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC;YACrB,IAAM,WAAS,GAAG,IAAI,CAAC;YAEvB,IAAI,CAAC,QAAQ,GAAG,2CACgB,YAAY,UAAK,WAAW,6CAC/B,MAAM,UAAK,OAAO,yiBAkBnB,YAAY,0FAGZ,QAAQ,CAAC,QAAQ,yFAIf,WAAW,8FAGX,QAAQ,CAAC,OAAO,wWAU1B,WAAS,kJAGK,WAAW,wHAM5C,CAAC;YACF,MAAM,CAAC;QACT,CAAC;QAED,IAAM,SAAS,GAAG,KAAK,CAAC;QAExB,IAAI,WAAW,GAAM,QAAQ,SAAI,QAAQ,SAAI,QAAQ,MAAG;YACpD,mEAAmE,CAAC;QACxE,EAAE,CAAC,CAAC,QAAQ,KAAK,KAAK,CAAC,CAAC,CAAC;YACvB,WAAW,GAAG,kBAAkB,CAAC;QACnC,CAAC;QAED,IAAM,sBAAsB,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;QAC/D,IAAM,wBAAwB,GAAG,WAAW,GAAG,CAAC,CAAC;QAEjD,IAAM,aAAa,GAAG,iBACd,SAAS,2FAGG,SAAS,0CAE5B,CAAC;QAEF,IAAI,CAAC,QAAQ,GAAG,yCACgB,YAAY,UAAK,WAAW,2CAC/B,MAAM,UAAK,OAAO,oDACT,mBAAmB,kLAM/B,QAAQ,CAAC,OAAO,+fAkBZ,mBAAmB,iGAIrB,YAAY,sFAGZ,QAAQ,CAAC,QAAQ,mFAIf,sBAAsB,mTAU1C,aAAa,uDAGK,sBAAsB,0BACtC,wBAAwB,KAAK,CAAC,mOAQhC,aAAa,gCACJ,wBAAwB,KAAK,CAAC,8OAQvC,aAAa,gCACJ,wBAAwB,KAAK,CAAC,yPAQvC,aAAa,oDAGP,WAAW,sBAE1B,CAAC;IACJ,CAAC;IACH,oBAAC;AAAD,CAAC,AA1LD,IA0LC\"}","dts":{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/rollup/tfjs-core/kernels/webgl/pool_gpu.d.ts","text":"import { Conv2DInfo } from '../../ops/conv_util';\r\nimport { GPGPUProgram } from './gpgpu_math';\r\nexport declare class Pool2DProgram implements GPGPUProgram {\r\n    variableNames: string[];\r\n    outputShape: number[];\r\n    userCode: string;\r\n    constructor(convInfo: Conv2DInfo, poolType: 'max' | 'avg', computePositions: boolean);\r\n}\r\n"}}
