{"code":"var ResizeBilinearProgram = (function () {\r\n    function ResizeBilinearProgram(inputShape, newHeight, newWidth, alignCorners) {\r\n        this.variableNames = ['A'];\r\n        this.outputShape = [];\r\n        var batch = inputShape[0], oldHeight = inputShape[1], oldWidth = inputShape[2], depth = inputShape[3];\r\n        this.outputShape = [batch, newHeight, newWidth, depth];\r\n        var effectiveInSize = [\r\n            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\r\n            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\r\n        ];\r\n        var effectiveOutSize = [\r\n            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\r\n            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\r\n        ];\r\n        this.userCode = \"\\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\\n          \" + effectiveInSize[0] / effectiveOutSize[0] + \",\\n          \" + effectiveInSize[1] / effectiveOutSize[1] + \");\\n      const vec2 inputShapeRC = vec2(\" + oldHeight + \".0, \" + oldWidth + \".0);\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        ivec2 yRC = coords.yz;\\n\\n        // Fractional source index.\\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\\n\\n        // Compute the four integer indices.\\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\\n        ivec2 sourceCeilRC = ivec2(\\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\\n\\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\\n\\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\\n\\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\\n        float newValue = top + (bottom - top) * fracRC.x;\\n\\n        setOutput(newValue);\\n      }\\n    \";\r\n    }\r\n    return ResizeBilinearProgram;\r\n}());\r\nexport { ResizeBilinearProgram };\r\n//# sourceMappingURL=resize_bilinear_gpu.js.map","map":"{\"version\":3,\"file\":\"resize_bilinear_gpu.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/kernels/webgl/resize_bilinear_gpu.ts\"],\"names\":[],\"mappings\":\"AAmBA;IAKE,+BACI,UAA4C,EAAE,SAAiB,EAC/D,QAAgB,EAAE,YAAqB;QAN3C,kBAAa,GAAG,CAAC,GAAG,CAAC,CAAC;QACtB,gBAAW,GAAa,EAAE,CAAC;QAMlB,IAAA,qBAAK,EAAE,yBAAS,EAAE,wBAAQ,EAAE,qBAAK,CAAe;QACvD,IAAI,CAAC,WAAW,GAAG,CAAC,KAAK,EAAE,SAAS,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;QAEvD,IAAM,eAAe,GAAqB;YACxC,CAAC,YAAY,IAAI,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC,SAAS;YAC3D,CAAC,YAAY,IAAI,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ;SACzD,CAAC;QAEF,IAAM,gBAAgB,GAAqB;YACzC,CAAC,YAAY,IAAI,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC,SAAS;YAC3D,CAAC,YAAY,IAAI,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ;SACzD,CAAC;QAEF,IAAI,CAAC,QAAQ,GAAG,2EAER,eAAe,CAAC,CAAC,CAAC,GAAG,gBAAgB,CAAC,CAAC,CAAC,qBACxC,eAAe,CAAC,CAAC,CAAC,GAAG,gBAAgB,CAAC,CAAC,CAAC,iDACb,SAAS,YAAO,QAAQ,ikCA6B1D,CAAC;IACJ,CAAC;IACH,4BAAC;AAAD,CAAC,AAxDD,IAwDC\"}","dts":{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/rollup/tfjs-core/kernels/webgl/resize_bilinear_gpu.d.ts","text":"import { GPGPUProgram } from './gpgpu_math';\r\nexport declare class ResizeBilinearProgram implements GPGPUProgram {\r\n    variableNames: string[];\r\n    outputShape: number[];\r\n    userCode: string;\r\n    constructor(inputShape: [number, number, number, number], newHeight: number, newWidth: number, alignCorners: boolean);\r\n}\r\n"}}
