{"code":"import { ENV } from '../../environment';\r\nimport * as util from '../../util';\r\nimport * as broadcast_util from '../../ops/broadcast_util';\r\nimport * as tex_util from './tex_util';\r\nexport function makeShader(inputsInfo, outputShape, userCode, broadcast) {\r\n    var sampleSnippet = getSampleSnippet();\r\n    var setOutputSnippet = getSetOutputSnippet();\r\n    var inputPrefixSnippet = inputsInfo.map(function (x) { return \"uniform sampler2D \" + x.name + \";\"; }).join('\\n');\r\n    var inputSamplingSnippet = inputsInfo.map(function (x) { return getInputSamplingSnippet(x, outputShape, broadcast); })\r\n        .join('\\n');\r\n    var outTexShape = outputShape.texShape;\r\n    var outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);\r\n    var source = [\r\n        SHADER_PREFIX, sampleSnippet, setOutputSnippet, inputPrefixSnippet,\r\n        outputSamplingSnippet, inputSamplingSnippet, userCode\r\n    ].join('\\n');\r\n    return source;\r\n}\r\nfunction getSampleSnippet() {\r\n    return ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED') ?\r\n        FLOAT_TEXTURE_SAMPLE_SNIPPET :\r\n        UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET;\r\n}\r\nfunction getSetOutputSnippet() {\r\n    return ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED') ?\r\n        FLOAT_TEXTURE_SETOUTPUT_SNIPPET :\r\n        UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET;\r\n}\r\nfunction getSamplerFromInInfo(inInfo) {\r\n    var shape = inInfo.shapeInfo.logicalShape;\r\n    switch (shape.length) {\r\n        case 0:\r\n            return getSamplerScalar(inInfo);\r\n        case 1:\r\n            return getSampler1D(inInfo);\r\n        case 2:\r\n            return getSampler2D(inInfo);\r\n        case 3:\r\n            return getSampler3D(inInfo);\r\n        case 4:\r\n            return getSampler4D(inInfo);\r\n        default:\r\n            throw new Error(shape.length + \"-D input sampling\" +\r\n                \" is not yet supported\");\r\n    }\r\n}\r\nfunction getInputSamplingSnippet(inInfo, outShapeInfo, broadcast) {\r\n    var res = getSamplerFlat(inInfo);\r\n    res += getSamplerFromInInfo(inInfo);\r\n    if (broadcast ||\r\n        util.arraysEqual(inInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape)) {\r\n        res += getSamplerAtOutputCoords(inInfo, outShapeInfo, broadcast);\r\n    }\r\n    return res;\r\n}\r\nfunction getOutputSamplingSnippet(outShape, outTexShape) {\r\n    switch (outShape.length) {\r\n        case 0:\r\n            return getOutputScalarCoords();\r\n        case 1:\r\n            return getOutput1DCoords(outShape, outTexShape);\r\n        case 2:\r\n            return getOutput2DCoords(outShape, outTexShape);\r\n        case 3:\r\n            return getOutput3DCoords(outShape, outTexShape);\r\n        case 4:\r\n            return getOutput4DCoords(outShape, outTexShape);\r\n        default:\r\n            throw new Error(outShape.length + \"-D output sampling is not yet supported\");\r\n    }\r\n}\r\nvar SAMPLE_1D_SNIPPET = \"\\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\";\r\nvar SAMPLE_2D_SNIPPET = \"\\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\\n  int index = row * numC + col;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\";\r\nvar SAMPLE_3D_SNIPPET = \"\\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\\n    int stride1, int row, int col, int depth) {\\n  // Explicitly use integer operations as dot() only works on floats.\\n  int index = row * stride0 + col * stride1 + depth;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\";\r\nvar SAMPLE_4D_SNIPPET = \"\\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\\n    int stride1, int stride2, int row, int col, int depth,\\n    int depth2) {\\n  // Explicitly use integer operations as dot() only works on floats.\\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\";\r\nvar UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET = \"\\n  uniform float NaN;\\n\\n  const vec4 floatDeltas = vec4(\\n      1.0,\\n      1.0 / 255.0,\\n      1.0 / (255.0 * 255.0),\\n      1.0 / (255.0 * 255.0 * 255.0)\\n  );\\n  const float minValue = \" + tex_util.FLOAT_MIN + \".0;\\n  const float maxValue = \" + tex_util.FLOAT_MAX + \".0;\\n  const float range = (maxValue - minValue) / 255.0;\\n  const vec2 dotRange = vec2(1.0, range);\\n\\n  float sampleTexture(sampler2D textureSampler, vec2 uv) {\\n    vec4 sampleValue = texture2D(textureSampler, uv);\\n    if (all(equal(sampleValue, vec4(\" + tex_util.BYTE_NAN_VALUE + \")))) {\\n      return NaN;\\n    }\\n\\n    vec4 encValue = floor(sampleValue * 255.0 + 0.5);\\n    float decodedValue = dot(encValue, floatDeltas);\\n    return dot(vec2(minValue, decodedValue), dotRange);\\n  }\\n\";\r\nvar UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET = \"\\n  const vec4 floatPowers = vec4(\\n    1.0,\\n    255.0,\\n    255.0 * 255.0,\\n    255.0 * 255.0 * 255.0\\n  );\\n  const vec2 recipRange = vec2(1.0/range);\\n  const vec2 recipRange255 = vec2(1.0/(maxValue - minValue));\\n\\n  void setOutput(float decodedValue) {\\n    if (isNaN(decodedValue)) {\\n      gl_FragColor = vec4(\" + tex_util.BYTE_NAN_VALUE + \");\\n      return;\\n    }\\n\\n    float a = dot(vec2(decodedValue, -minValue), recipRange);\\n    float b = fract(a) * 255.0;\\n    float c = fract(b) * 255.0;\\n    float d = fract(c) * 255.0;\\n    gl_FragColor = floor(vec4(a, b, c, d)) / 255.0;\\n\\n    // TODO(dsmilkov): Version above gets better accuracy but probably slower\\n    // than the version below. Benchmark to determine if the accuracy is worth\\n    // the cost.\\n\\n    // float normValue = dot(vec2(decodedValue, -minValue), recipRange255);\\n    // vec4 f = normValue * floatPowers;\\n    // gl_FragColor = floor(fract(f) * 255.0) / 255.0;\\n  }\\n\";\r\nvar FLOAT_TEXTURE_SAMPLE_SNIPPET = \"\\n  float sampleTexture(sampler2D textureSampler, vec2 uv) {\\n    return texture2D(textureSampler, uv).r;\\n  }\\n\";\r\nvar FLOAT_TEXTURE_SETOUTPUT_SNIPPET = \"\\n  void setOutput(float val) {\\n    gl_FragColor = vec4(val, 0, 0, 0);\\n  }\\n\";\r\nvar SHADER_PREFIX = \"\\n  precision highp float;\\n  precision highp int;\\n  varying vec2 resultUV;\\n  const vec2 halfCR = vec2(0.5, 0.5);\\n\\n  bool isNaN(float val) {\\n    float v1 = val * val;\\n    float v2 = val * val;\\n    return v1 == v2 ? false : true;\\n  }\\n\\n  bool hasNaN(vec4 values) {\\n    vec4 v1 = values * values;\\n    vec4 v2 = values * values;\\n    return any(notEqual(v1, v2));\\n  }\\n\\n  float getNaN(vec4 values) {\\n    return dot(vec4(1), values);\\n  }\\n\\n  int round(float value) {\\n    return int(floor(value + 0.5));\\n  }\\n\\n  int imod(int x, int y) {\\n    return x - y * (x / y);\\n  }\\n\\n  //Based on the work of Dave Hoskins\\n  //https://www.shadertoy.com/view/4djSRW\\n  #define HASHSCALE1 443.8975\\n  float random(float seed){\\n    vec2 p = resultUV * seed;\\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n  }\\n\\n  \" + SAMPLE_1D_SNIPPET + \"\\n  \" + SAMPLE_2D_SNIPPET + \"\\n  \" + SAMPLE_3D_SNIPPET + \"\\n  \" + SAMPLE_4D_SNIPPET + \"\\n\";\r\nfunction getOutputScalarCoords() {\r\n    return \"\\n    int getOutputCoords() {\\n      return 0;\\n    }\\n  \";\r\n}\r\nfunction getOutput1DCoords(shape, texShape) {\r\n    if (texShape[0] === 1) {\r\n        return \"\\n      int getOutputCoords() {\\n        return int(resultUV.x * \" + texShape[1] + \".0);\\n      }\\n    \";\r\n    }\r\n    if (texShape[1] === 1) {\r\n        return \"\\n      int getOutputCoords() {\\n        return int(resultUV.y * \" + texShape[0] + \".0);\\n      }\\n    \";\r\n    }\r\n    return \"\\n    int getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      return resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n    }\\n  \";\r\n}\r\nfunction getOutput3DCoords(shape, texShape) {\r\n    var stride0 = shape[1] * shape[2];\r\n    var stride1 = shape[2];\r\n    return \"\\n    ivec3 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n      int r = index / \" + stride0 + \";\\n      index -= r * \" + stride0 + \";\\n      int c = index / \" + stride1 + \";\\n      int d = index - c * \" + stride1 + \";\\n      return ivec3(r, c, d);\\n    }\\n  \";\r\n}\r\nfunction getOutput4DCoords(shape, texShape) {\r\n    var stride2 = shape[3];\r\n    var stride1 = shape[2] * stride2;\r\n    var stride0 = shape[1] * stride1;\r\n    return \"\\n    ivec4 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n        vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n\\n      int r = index / \" + stride0 + \";\\n      index -= r * \" + stride0 + \";\\n\\n      int c = index / \" + stride1 + \";\\n      index -= c * \" + stride1 + \";\\n\\n      int d = index / \" + stride2 + \";\\n      int d2 = index - d * \" + stride2 + \";\\n\\n      return ivec4(r, c, d, d2);\\n    }\\n  \";\r\n}\r\nfunction getOutput2DCoords(shape, texShape) {\r\n    if (util.arraysEqual(shape, texShape)) {\r\n        return \"\\n      ivec2 getOutputCoords() {\\n        return ivec2(resultUV.yx * vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      }\\n    \";\r\n    }\r\n    if (shape[1] === 1) {\r\n        return \"\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n        int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n        return ivec2(index, 0);\\n      }\\n    \";\r\n    }\r\n    if (shape[0] === 1) {\r\n        return \"\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n        int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n        return ivec2(0, index);\\n      }\\n    \";\r\n    }\r\n    return \"\\n    ivec2 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n      int r = index / \" + shape[1] + \";\\n      int c = index - r * \" + shape[1] + \";\\n      return ivec2(r, c);\\n    }\\n  \";\r\n}\r\nfunction getSamplerScalar(inputInfo) {\r\n    var texName = inputInfo.name;\r\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\r\n    return \"\\n    float \" + funcName + \"() {\\n      return sampleTexture(\" + texName + \", halfCR);\\n    }\\n  \";\r\n}\r\nfunction getSampler1D(inputInfo) {\r\n    var texName = inputInfo.name;\r\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\r\n    return \"\\n    float \" + funcName + \"(int index) {\\n      return \" + funcName + \"Flat(index);\\n    }\\n  \";\r\n}\r\nfunction getSampler2D(inputInfo) {\r\n    var shape = inputInfo.shapeInfo.logicalShape;\r\n    var texShape = inputInfo.shapeInfo.texShape;\r\n    var texName = inputInfo.name;\r\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\r\n    var texNumR = texShape[0];\r\n    var texNumC = texShape[1];\r\n    if (util.arraysEqual(shape, texShape)) {\r\n        return \"\\n    float \" + funcName + \"(int row, int col) {\\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(\" + texNumC + \".0, \" + texNumR + \".0);\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\r\n    }\r\n    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;\r\n    var squeezedShape = newShape;\r\n    if (squeezedShape.length < shape.length) {\r\n        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\r\n        var params = ['row', 'col'];\r\n        return \"\\n      \" + getSamplerFromInInfo(newInputInfo) + \"\\n      float \" + funcName + \"(int row, int col) {\\n        return \" + funcName + \"(\" + getSqueezedParams(params, keptDims) + \");\\n      }\\n    \";\r\n    }\r\n    if (texNumC === 1) {\r\n        return \"\\n    float \" + funcName + \"(int row, int col) {\\n      int index = row * \" + shape[1] + \" + col;\\n      vec2 uv = vec2(0.5, (float(index) + 0.5) / \" + texNumR + \".0);\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\r\n    }\r\n    if (texNumR === 1) {\r\n        return \"\\n    float \" + funcName + \"(int row, int col) {\\n      int index = row * \" + shape[1] + \" + col;\\n      vec2 uv = vec2((float(index) + 0.5) / \" + texNumC + \".0, 0.5);\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\r\n    }\r\n    return \"\\n  float \" + funcName + \"(int row, int col) {\\n    vec2 uv = UVfrom2D(\" + texNumR + \", \" + texNumC + \", \" + shape[1] + \", row, col);\\n    return sampleTexture(\" + texName + \", uv);\\n  }\\n\";\r\n}\r\nfunction getSampler3D(inputInfo) {\r\n    var texShape = inputInfo.shapeInfo.texShape;\r\n    var shape = inputInfo.shapeInfo.logicalShape;\r\n    var texName = inputInfo.name;\r\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\r\n    var texNumR = texShape[0];\r\n    var texNumC = texShape[1];\r\n    var stride0 = shape[1] * shape[2];\r\n    var stride1 = shape[2];\r\n    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;\r\n    var squeezedShape = newShape;\r\n    if (squeezedShape.length < shape.length) {\r\n        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\r\n        var params = ['row', 'col', 'depth'];\r\n        return \"\\n        \" + getSamplerFromInInfo(newInputInfo) + \"\\n        float \" + funcName + \"(int row, int col, int depth) {\\n          return \" + funcName + \"(\" + getSqueezedParams(params, keptDims) + \");\\n        }\\n      \";\r\n    }\r\n    if (texNumC === stride0) {\r\n        return \"\\n        float \" + funcName + \"(int row, int col, int depth) {\\n          int texR = row;\\n          int texC = col * \" + stride1 + \" + depth;\\n          vec2 uv = (vec2(texC, texR) + halfCR) /\\n                     vec2(\" + texNumC + \".0, \" + texNumR + \".0);\\n          return sampleTexture(\" + texName + \", uv);\\n        }\\n      \";\r\n    }\r\n    if (texNumC === stride1) {\r\n        return \"\\n    float \" + funcName + \"(int row, int col, int depth) {\\n      int texR = row * \" + shape[1] + \" + col;\\n      int texC = depth;\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + texNumC + \".0, \" + texNumR + \".0);\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\r\n    }\r\n    return \"\\n      float \" + funcName + \"(int row, int col, int depth) {\\n        vec2 uv = UVfrom3D(\\n            \" + texNumR + \", \" + texNumC + \", \" + stride0 + \", \" + stride1 + \", row, col, depth);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n  \";\r\n}\r\nfunction getSampler4D(inputInfo) {\r\n    var shape = inputInfo.shapeInfo.logicalShape;\r\n    var texShape = inputInfo.shapeInfo.texShape;\r\n    var texName = inputInfo.name;\r\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\r\n    var texNumR = texShape[0];\r\n    var texNumC = texShape[1];\r\n    var stride2 = shape[3];\r\n    var stride1 = shape[2] * stride2;\r\n    var stride0 = shape[1] * stride1;\r\n    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;\r\n    if (newShape.length < shape.length) {\r\n        var newInputInfo = squeezeInputInfo(inputInfo, newShape);\r\n        var params = ['row', 'col', 'depth', 'depth2'];\r\n        return \"\\n      \" + getSamplerFromInInfo(newInputInfo) + \"\\n      float \" + funcName + \"(int row, int col, int depth, int depth2) {\\n        return \" + funcName + \"(\" + getSqueezedParams(params, keptDims) + \");\\n      }\\n    \";\r\n    }\r\n    if (texNumC === stride0) {\r\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth, int depth2) {\\n        int texR = row;\\n        int texC = col * \" + stride1 + \" + depth * \" + stride2 + \" + depth2;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + texNumC + \".0, \" + texNumR + \".0);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n    \";\r\n    }\r\n    if (texNumC === stride2) {\r\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth, int depth2) {\\n        int texR = row * \" + shape[1] * shape[2] + \" + col * \" + shape[2] + \" + depth;\\n        int texC = depth2;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + texNumC + \".0, \" + texNumR + \".0);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n    \";\r\n    }\r\n    return \"\\n    float \" + funcName + \"(int row, int col, int depth, int depth2) {\\n      vec2 uv = UVfrom4D(\" + texNumR + \", \" + texNumC + \", \" + stride0 + \", \" + stride1 + \",\\n          \" + stride2 + \", row, col, depth, depth2);\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\r\n}\r\nfunction getSamplerFlat(inputInfo) {\r\n    var texName = inputInfo.name;\r\n    var texShape = inputInfo.shapeInfo.texShape;\r\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1) + 'Flat';\r\n    var tNumR = texShape[0];\r\n    var tNumC = texShape[1];\r\n    if (tNumC === 1 && tNumR === 1) {\r\n        return \"\\n      float \" + funcName + \"(int index) {\\n        return sampleTexture(\" + texName + \", halfCR);\\n      }\\n    \";\r\n    }\r\n    if (tNumC === 1) {\r\n        return \"\\n      float \" + funcName + \"(int index) {\\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / \" + tNumR + \".0);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n    \";\r\n    }\r\n    if (tNumR === 1) {\r\n        return \"\\n      float \" + funcName + \"(int index) {\\n        vec2 uv = vec2((float(index) + 0.5) / \" + tNumC + \".0, 0.5);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n    \";\r\n    }\r\n    return \"\\n    float \" + funcName + \"(int index) {\\n      vec2 uv = UVfrom1D(\" + tNumR + \", \" + tNumC + \", index);\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\r\n}\r\nfunction getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName) {\r\n    var inRank = inputInfo.shapeInfo.logicalShape.length;\r\n    var outRank = outShapeInfo.logicalShape.length;\r\n    var type = 'int';\r\n    if (outRank === 2) {\r\n        type = 'ivec2';\r\n    }\r\n    else if (outRank === 3) {\r\n        type = 'ivec3';\r\n    }\r\n    else if (outRank === 4) {\r\n        type = 'ivec4';\r\n    }\r\n    var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\r\n    var rankDiff = outRank - inRank;\r\n    var coordsSnippet;\r\n    if (inRank === 0) {\r\n        coordsSnippet = '';\r\n    }\r\n    else if (outRank < 2 && broadcastDims.length >= 1) {\r\n        coordsSnippet = 'coords = 0;';\r\n    }\r\n    else {\r\n        coordsSnippet =\r\n            broadcastDims.map(function (d) { return \"coords[\" + (d + rankDiff) + \"] = 0;\"; }).join('\\n');\r\n    }\r\n    var unpackedCoordsSnippet = '';\r\n    if (outRank < 2 && inRank > 0) {\r\n        unpackedCoordsSnippet = 'coords';\r\n    }\r\n    else {\r\n        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape\r\n            .map(function (s, i) { return \"coords[\" + (i + rankDiff) + \"]\"; })\r\n            .join(', ');\r\n    }\r\n    return \"\\n    float \" + funcName + \"() {\\n      \" + type + \" coords = getOutputCoords();\\n      \" + coordsSnippet + \"\\n      return get\" + texFuncSnippet + \"(\" + unpackedCoordsSnippet + \");\\n    }\\n  \";\r\n}\r\nfunction getSamplerAtOutputCoords(inputInfo, outShapeInfo, supportsBroadcasting) {\r\n    var inTexShape = inputInfo.shapeInfo.texShape;\r\n    var texName = inputInfo.name;\r\n    var texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\r\n    var funcName = 'get' + texFuncSnippet + 'AtOutCoords';\r\n    var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\r\n    var inRank = inputInfo.shapeInfo.logicalShape.length;\r\n    var outRank = outShapeInfo.logicalShape.length;\r\n    var doBroadcast = supportsBroadcasting && ((outRank > inRank) || broadcastDims.length > 0);\r\n    var broadcastOverOuter = broadcast_util.broadcastDimsAreOuter(broadcastDims);\r\n    if (doBroadcast && !broadcastOverOuter) {\r\n        return getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName);\r\n    }\r\n    var outTexShape = outShapeInfo.texShape;\r\n    if (util.arraysEqual(inTexShape, outTexShape)) {\r\n        return \"\\n      float \" + funcName + \"() {\\n        return sampleTexture(\" + texName + \", resultUV);\\n      }\\n    \";\r\n    }\r\n    var inSize = util.sizeFromShape(inTexShape);\r\n    var broadcastSnippet = '';\r\n    if (doBroadcast && broadcastOverOuter) {\r\n        broadcastSnippet = \"\\n        int mainPart = index / \" + inSize + \";\\n        index -= mainPart * \" + inSize + \";\\n      \";\r\n    }\r\n    return \"\\n    float \" + funcName + \"() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + outTexShape[0] + \", \" + outTexShape[1] + \"));\\n      int index = resTexRC.x * \" + outTexShape[1] + \" + resTexRC.y;\\n      \" + broadcastSnippet + \"\\n      int texR = index / \" + inTexShape[1] + \";\\n      int texC = index - texR * \" + inTexShape[1] + \";\\n      vec2 uv = (vec2(texC, texR) + halfCR) /\\n                 vec2(\" + inTexShape[1] + \".0, \" + inTexShape[0] + \".0);\\n\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\r\n}\r\nexport function getCoordsDataType(rank) {\r\n    if (rank <= 1) {\r\n        return 'int';\r\n    }\r\n    else if (rank === 2) {\r\n        return 'ivec2';\r\n    }\r\n    else if (rank === 3) {\r\n        return 'ivec3';\r\n    }\r\n    else if (rank === 4) {\r\n        return 'ivec4';\r\n    }\r\n    else {\r\n        throw Error(\"GPU for rank \" + rank + \" is not yet supported\");\r\n    }\r\n}\r\nfunction squeezeInputInfo(inInfo, squeezedShape) {\r\n    var newInputInfo = JSON.parse(JSON.stringify(inInfo));\r\n    newInputInfo.shapeInfo.logicalShape = squeezedShape;\r\n    return newInputInfo;\r\n}\r\nfunction getSqueezedParams(params, keptDims) {\r\n    return keptDims.map(function (d) { return params[d]; }).join(', ');\r\n}\r\n//# sourceMappingURL=shader_compiler.js.map","map":"{\"version\":3,\"file\":\"shader_compiler.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/kernels/webgl/shader_compiler.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/rollup/tfjs-core/kernels/webgl/shader_compiler.d.ts","text":"export declare type ShapeInfo = {\r\n    logicalShape: number[];\r\n    texShape: [number, number];\r\n};\r\nexport declare type InputInfo = {\r\n    name: string;\r\n    shapeInfo: ShapeInfo;\r\n};\r\nexport declare function makeShader(inputsInfo: InputInfo[], outputShape: ShapeInfo, userCode: string, broadcast: boolean): string;\r\nexport declare function getCoordsDataType(rank: number): string;\r\n"}}
