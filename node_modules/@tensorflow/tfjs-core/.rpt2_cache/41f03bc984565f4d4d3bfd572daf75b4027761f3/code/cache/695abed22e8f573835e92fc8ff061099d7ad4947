{"code":"import * as tslib_1 from \"tslib\";\r\nimport { doc } from './doc';\r\nimport { ENV } from './environment';\r\nimport { tidy } from './globals';\r\nimport { Tensor, Variable } from './tensor';\r\nimport * as util from './util';\r\nvar Gradients = (function () {\r\n    function Gradients() {\r\n    }\r\n    Gradients.gradScope = function (nameOrScopeFn, scopeFn) {\r\n        return tidy(nameOrScopeFn, scopeFn, true);\r\n    };\r\n    Gradients.grad = function (f) {\r\n        util.assert(util.isFunction(f), 'The f passed in grad(f) must be a function');\r\n        return function (x, dy) {\r\n            util.assert(x instanceof Tensor, 'The x passed in grad(f)(x) must be a tensor');\r\n            util.assert(dy == null || dy instanceof Tensor, 'The dy passed in grad(f)(x, dy) must be a tensor');\r\n            return tidy(function () {\r\n                var _a = ENV.engine.gradients(function () { return f(x); }, [x], dy), value = _a.value, grads = _a.grads;\r\n                if (dy != null) {\r\n                    util.assertShapesMatch(value.shape, dy.shape, 'The shape of dy passed in grad(f)(x, dy) must match the shape ' +\r\n                        'returned by f(x)');\r\n                }\r\n                checkGrads(grads);\r\n                return grads[0];\r\n            });\r\n        };\r\n    };\r\n    Gradients.grads = function (f) {\r\n        util.assert(util.isFunction(f), 'The f passed in grads(f) must be a function');\r\n        return function (args, dy) {\r\n            util.assert(Array.isArray(args) && args.every(function (arg) { return arg instanceof Tensor; }), 'The args passed in grads(f)(args) must be an array of tensors');\r\n            util.assert(dy == null || dy instanceof Tensor, 'The dy passed in grads(f)(args, dy) must be a tensor');\r\n            return tidy(function () {\r\n                var _a = ENV.engine.gradients(function () { return f.apply(void 0, args); }, args, dy), value = _a.value, grads = _a.grads;\r\n                if (dy != null) {\r\n                    util.assertShapesMatch(value.shape, dy.shape, 'The shape of dy passed in grads(f)([x1,...], dy) must ' +\r\n                        'match the shape returned by f([x1,...])');\r\n                }\r\n                checkGrads(grads);\r\n                return grads;\r\n            });\r\n        };\r\n    };\r\n    Gradients.valueAndGrad = function (f) {\r\n        util.assert(util.isFunction(f), 'The f passed in valueAndGrad(f) must be a function');\r\n        return function (x, dy) {\r\n            util.assert(x instanceof Tensor, 'The x passed in valueAndGrad(f)(x) must be a tensor');\r\n            util.assert(dy == null || dy instanceof Tensor, 'The dy passed in valueAndGrad(f)(x, dy) must be a tensor');\r\n            var _a = ENV.engine.gradients(function () { return f(x); }, [x], dy), grads = _a.grads, value = _a.value;\r\n            checkGrads(grads);\r\n            return { grad: grads[0], value: value };\r\n        };\r\n    };\r\n    Gradients.valueAndGrads = function (f) {\r\n        util.assert(util.isFunction(f), 'The f passed in valueAndGrads(f) must be a function');\r\n        return function (args, dy) {\r\n            util.assert(Array.isArray(args) && args.every(function (arg) { return arg instanceof Tensor; }), 'The args passed in valueAndGrads(f)(args) must be array of tensors');\r\n            util.assert(dy == null || dy instanceof Tensor, 'The dy passed in valueAndGrads(f)(args, dy) must be a tensor');\r\n            var res = ENV.engine.gradients(function () { return f.apply(void 0, args); }, args, dy);\r\n            if (dy != null) {\r\n                util.assertShapesMatch(res.value.shape, dy.shape, 'The shape of dy passed in valueAndGrads(f)([x1,...], dy) must ' +\r\n                    'match the shape returned by f([x1,...])');\r\n            }\r\n            checkGrads(res.grads);\r\n            return res;\r\n        };\r\n    };\r\n    Gradients.variableGrads = function (f, varList) {\r\n        util.assert(util.isFunction(f), 'The f passed in variableGrads(f) must be a function');\r\n        util.assert(varList == null ||\r\n            Array.isArray(varList) && varList.every(function (v) { return v instanceof Variable; }), 'The varList passed in variableGrads(f, varList) must be an array ' +\r\n            'of variables');\r\n        if (varList == null) {\r\n            varList = [];\r\n            for (var varName in ENV.engine.registeredVariables) {\r\n                varList.push(ENV.engine.registeredVariables[varName]);\r\n            }\r\n        }\r\n        var originalVarCount = varList.length;\r\n        varList = varList.filter(function (variable) { return variable.trainable; });\r\n        util.assert(varList.length > 0, \"variableGrads() expects at least one of the input variables to be \" +\r\n            (\"trainable, but none of the \" + originalVarCount + \" variables is \") +\r\n            \"trainable.\");\r\n        var allowNoGradients = true;\r\n        var _a = ENV.engine.gradients(f, varList, null, allowNoGradients), value = _a.value, grads = _a.grads;\r\n        util.assert(grads.some(function (g) { return g != null; }), 'Cannot find a connection between any variable and the result of the ' +\r\n            'loss function y=f(x). Please make sure the operations that use ' +\r\n            'variables are inside the function f passed to minimize().');\r\n        util.assert(value.rank === 0, \"The f passed in variableGrads(f) must return a scalar, but it \" +\r\n            (\"returned a rank-\" + value.rank + \" tensor\"));\r\n        var namedGrads = {};\r\n        varList.forEach(function (v, i) {\r\n            if (grads[i] != null) {\r\n                namedGrads[v.name] = grads[i];\r\n            }\r\n        });\r\n        return { value: value, grads: namedGrads };\r\n    };\r\n    Gradients.customGrad = function (f) {\r\n        return ENV.engine.customGrad(f);\r\n    };\r\n    tslib_1.__decorate([\r\n        doc({ heading: 'Training', subheading: 'Gradients' })\r\n    ], Gradients, \"grad\", null);\r\n    tslib_1.__decorate([\r\n        doc({ heading: 'Training', subheading: 'Gradients' })\r\n    ], Gradients, \"grads\", null);\r\n    tslib_1.__decorate([\r\n        doc({ heading: 'Training', subheading: 'Gradients' })\r\n    ], Gradients, \"valueAndGrad\", null);\r\n    tslib_1.__decorate([\r\n        doc({ heading: 'Training', subheading: 'Gradients' })\r\n    ], Gradients, \"valueAndGrads\", null);\r\n    tslib_1.__decorate([\r\n        doc({ heading: 'Training', subheading: 'Gradients' })\r\n    ], Gradients, \"variableGrads\", null);\r\n    tslib_1.__decorate([\r\n        doc({ heading: 'Training', subheading: 'Gradients' })\r\n    ], Gradients, \"customGrad\", null);\r\n    return Gradients;\r\n}());\r\nexport { Gradients };\r\nfunction checkGrads(grads) {\r\n    var numNullGradients = grads.filter(function (g) { return g == null; }).length;\r\n    if (numNullGradients > 0) {\r\n        throw new Error(\"Cannot compute gradient of y=f(x) with respect to x. Make sure that\\n    the f you passed encloses all operations that lead from x to y.\");\r\n    }\r\n}\r\n//# sourceMappingURL=gradients.js.map","map":"{\"version\":3,\"file\":\"gradients.js\",\"sourceRoot\":\"\",\"sources\":[\"src/gradients.ts\"],\"names\":[],\"mappings\":\";AAiBA,OAAO,EAAC,GAAG,EAAC,MAAM,OAAO,CAAC;AAG1B,OAAO,EAAC,GAAG,EAAC,MAAM,eAAe,CAAC;AAClC,OAAO,EAAC,IAAI,EAAC,MAAM,WAAW,CAAC;AAC/B,OAAO,EAAS,MAAM,EAAE,QAAQ,EAAC,MAAM,UAAU,CAAC;AAElD,OAAO,KAAK,IAAI,MAAM,QAAQ,CAAC;AAE/B;IAAA;IA6UA,CAAC;IAjUQ,mBAAS,GAAhB,UACI,aAAgC,EAAE,OAAoB;QACxD,MAAM,CAAC,IAAI,CAAC,aAAa,EAAE,OAAO,EAAE,IAAI,CAAiB,CAAC;IAC5D,CAAC;IAmCM,cAAI,GAAX,UAAgD,CAAc;QAE5D,IAAI,CAAC,MAAM,CACP,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,4CAA4C,CAAC,CAAC;QACtE,MAAM,CAAC,UAAC,CAAI,EAAE,EAAM;YAClB,IAAI,CAAC,MAAM,CACP,CAAC,YAAY,MAAM,EAAE,6CAA6C,CAAC,CAAC;YACxE,IAAI,CAAC,MAAM,CACP,EAAE,IAAI,IAAI,IAAI,EAAE,YAAY,MAAM,EAClC,kDAAkD,CAAC,CAAC;YACxD,MAAM,CAAC,IAAI,CAAC;gBACJ,IAAA,gEAA0D,EAAzD,gBAAK,EAAE,gBAAK,CAA8C;gBACjE,EAAE,CAAC,CAAC,EAAE,IAAI,IAAI,CAAC,CAAC,CAAC;oBACf,IAAI,CAAC,iBAAiB,CAClB,KAAK,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,EACrB,gEAAgE;wBAChE,kBAAkB,CAAC,CAAC;gBAC1B,CAAC;gBACD,UAAU,CAAC,KAAK,CAAC,CAAC;gBAClB,MAAM,CAAC,KAAK,CAAC,CAAC,CAAM,CAAC;YACvB,CAAC,CAAC,CAAC;QACL,CAAC,CAAC;IACJ,CAAC;IA8BM,eAAK,GAAZ,UAA+B,CAA2B;QAExD,IAAI,CAAC,MAAM,CACP,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,6CAA6C,CAAC,CAAC;QACvE,MAAM,CAAC,UAAC,IAAc,EAAE,EAAM;YAC5B,IAAI,CAAC,MAAM,CACP,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,UAAA,GAAG,IAAI,OAAA,GAAG,YAAY,MAAM,EAArB,CAAqB,CAAC,EAC/D,+DAA+D,CAAC,CAAC;YACrE,IAAI,CAAC,MAAM,CACP,EAAE,IAAI,IAAI,IAAI,EAAE,YAAY,MAAM,EAClC,sDAAsD,CAAC,CAAC;YAC5D,MAAM,CAAC,IAAI,CAAC;gBACJ,IAAA,kFAAiE,EAAhE,gBAAK,EAAE,gBAAK,CAAqD;gBACxE,EAAE,CAAC,CAAC,EAAE,IAAI,IAAI,CAAC,CAAC,CAAC;oBACf,IAAI,CAAC,iBAAiB,CAClB,KAAK,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,EACrB,wDAAwD;wBACxD,yCAAyC,CAAC,CAAC;gBACjD,CAAC;gBACD,UAAU,CAAC,KAAK,CAAC,CAAC;gBAClB,MAAM,CAAC,KAAK,CAAC;YACf,CAAC,CAAC,CAAC;QACL,CAAC,CAAC;IACJ,CAAC;IA0BM,sBAAY,GAAnB,UAAwD,CAAc;QAKpE,IAAI,CAAC,MAAM,CACP,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,EAClB,oDAAoD,CAAC,CAAC;QAC1D,MAAM,CAAC,UAAC,CAAI,EAAE,EAAM;YAClB,IAAI,CAAC,MAAM,CACP,CAAC,YAAY,MAAM,EACnB,qDAAqD,CAAC,CAAC;YAC3D,IAAI,CAAC,MAAM,CACP,EAAE,IAAI,IAAI,IAAI,EAAE,YAAY,MAAM,EAClC,0DAA0D,CAAC,CAAC;YAC1D,IAAA,gEAA0D,EAAzD,gBAAK,EAAE,gBAAK,CAA8C;YACjE,UAAU,CAAC,KAAK,CAAC,CAAC;YAClB,MAAM,CAAC,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAM,EAAE,KAAK,EAAE,KAAU,EAAC,CAAC;QAClD,CAAC,CAAC;IACJ,CAAC;IAgCM,uBAAa,GAApB,UAAuC,CAA2B;QAKhE,IAAI,CAAC,MAAM,CACP,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,EAClB,qDAAqD,CAAC,CAAC;QAC3D,MAAM,CAAC,UAAC,IAAc,EAAE,EAAM;YAC5B,IAAI,CAAC,MAAM,CACP,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,UAAA,GAAG,IAAI,OAAA,GAAG,YAAY,MAAM,EAArB,CAAqB,CAAC,EAC/D,oEAAoE,CAAC,CAAC;YAC1E,IAAI,CAAC,MAAM,CACP,EAAE,IAAI,IAAI,IAAI,EAAE,YAAY,MAAM,EAClC,8DAA8D,CAAC,CAAC;YACpE,IAAM,GAAG,GAAG,GAAG,CAAC,MAAM,CAAC,SAAS,CAAC,cAAM,OAAA,CAAC,eAAI,IAAI,GAAT,CAAU,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC;YAC7D,EAAE,CAAC,CAAC,EAAE,IAAI,IAAI,CAAC,CAAC,CAAC;gBACf,IAAI,CAAC,iBAAiB,CAClB,GAAG,CAAC,KAAK,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,EACzB,gEAAgE;oBAC5D,yCAAyC,CAAC,CAAC;YACrD,CAAC;YACD,UAAU,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YACtB,MAAM,CAAC,GAAG,CAAC;QACb,CAAC,CAAC;IACJ,CAAC;IAwBM,uBAAa,GAApB,UAAqB,CAAe,EAAE,OAAoB;QAExD,IAAI,CAAC,MAAM,CACP,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,EAClB,qDAAqD,CAAC,CAAC;QAC3D,IAAI,CAAC,MAAM,CACP,OAAO,IAAI,IAAI;YACX,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,OAAO,CAAC,KAAK,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,YAAY,QAAQ,EAArB,CAAqB,CAAC,EACvE,mEAAmE;YAC/D,cAAc,CAAC,CAAC;QACxB,EAAE,CAAC,CAAC,OAAO,IAAI,IAAI,CAAC,CAAC,CAAC;YAEpB,OAAO,GAAG,EAAE,CAAC;YACb,GAAG,CAAC,CAAC,IAAM,OAAO,IAAI,GAAG,CAAC,MAAM,CAAC,mBAAmB,CAAC,CAAC,CAAC;gBACrD,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,mBAAmB,CAAC,OAAO,CAAC,CAAC,CAAC;YACxD,CAAC;QACH,CAAC;QAED,IAAM,gBAAgB,GAAG,OAAO,CAAC,MAAM,CAAC;QACxC,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,SAAS,EAAlB,CAAkB,CAAC,CAAC;QACzD,IAAI,CAAC,MAAM,CACP,OAAO,CAAC,MAAM,GAAG,CAAC,EAClB,oEAAoE;aAChE,gCAA8B,gBAAgB,mBAAgB,CAAA;YAC9D,YAAY,CAAC,CAAC;QAEtB,IAAM,gBAAgB,GAAG,IAAI,CAAC;QACxB,IAAA,6DACsD,EADrD,gBAAK,EAAE,gBAAK,CAC0C;QAE7D,IAAI,CAAC,MAAM,CACP,KAAK,CAAC,IAAI,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,IAAI,IAAI,EAAT,CAAS,CAAC,EAC1B,sEAAsE;YAClE,iEAAiE;YACjE,2DAA2D,CAAC,CAAC;QACrE,IAAI,CAAC,MAAM,CACP,KAAK,CAAC,IAAI,KAAK,CAAC,EAChB,gEAAgE;aAC5D,qBAAmB,KAAK,CAAC,IAAI,YAAS,CAAA,CAAC,CAAC;QAEhD,IAAM,UAAU,GAAmB,EAAE,CAAC;QACtC,OAAO,CAAC,OAAO,CAAC,UAAC,CAAC,EAAE,CAAC;YACnB,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC;gBACrB,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YAChC,CAAC;QACH,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,EAAC,KAAK,OAAA,EAAE,KAAK,EAAE,UAAU,EAAC,CAAC;IACpC,CAAC;IA+BM,oBAAU,GAAjB,UAAoC,CAAwB;QAE1D,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;IAClC,CAAC;IA1RD;QADC,GAAG,CAAC,EAAC,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,WAAW,EAAC,CAAC;+BAuBnD;IA8BD;QADC,GAAG,CAAC,EAAC,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,WAAW,EAAC,CAAC;gCAwBnD;IA0BD;QADC,GAAG,CAAC,EAAC,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,WAAW,EAAC,CAAC;uCAoBnD;IAgCD;QADC,GAAG,CAAC,EAAC,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,WAAW,EAAC,CAAC;wCA0BnD;IAwBD;QADC,GAAG,CAAC,EAAC,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,WAAW,EAAC,CAAC;wCAgDnD;IA+BD;QADC,GAAG,CAAC,EAAC,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,WAAW,EAAC,CAAC;qCAInD;IACH,gBAAC;CAAA,AA7UD,IA6UC;SA7UY,SAAS;AA+UtB,oBAAoB,KAAe;IACjC,IAAM,gBAAgB,GAAG,KAAK,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,IAAI,IAAI,EAAT,CAAS,CAAC,CAAC,MAAM,CAAC;IAC7D,EAAE,CAAC,CAAC,gBAAgB,GAAG,CAAC,CAAC,CAAC,CAAC;QACzB,MAAM,IAAI,KAAK,CACX,0IAC4D,CAAC,CAAC;IACpE,CAAC;AACH,CAAC\"}","dts":{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/rollup/tfjs-core/gradients.d.ts","text":"import { CustomGradientFunc } from './engine';\r\nimport { ScopeFn } from './engine';\r\nimport { Scalar, Tensor, Variable } from './tensor';\r\nimport { NamedTensorMap, TensorContainer } from './types';\r\nexport declare class Gradients {\r\n    static gradScope<T extends TensorContainer>(nameOrScopeFn: string | ScopeFn<T>, scopeFn?: ScopeFn<T>): T;\r\n    static grad<I extends Tensor, O extends Tensor>(f: (x: I) => O): (x: I, dy?: O) => I;\r\n    static grads<O extends Tensor>(f: (...args: Tensor[]) => O): (args: Tensor[], dy?: O) => Tensor[];\r\n    static valueAndGrad<I extends Tensor, O extends Tensor>(f: (x: I) => O): (x: I, dy?: O) => {\r\n        value: O;\r\n        grad: I;\r\n    };\r\n    static valueAndGrads<O extends Tensor>(f: (...args: Tensor[]) => O): (args: Tensor[], dy?: O) => {\r\n        grads: Tensor[];\r\n        value: O;\r\n    };\r\n    static variableGrads(f: () => Scalar, varList?: Variable[]): {\r\n        value: Scalar;\r\n        grads: NamedTensorMap;\r\n    };\r\n    static customGrad<T extends Tensor>(f: CustomGradientFunc<T>): (...args: Tensor[]) => T;\r\n}\r\n"}}
