{"code":"import * as tslib_1 from \"tslib\";\r\nimport { doc } from '../doc';\r\nimport * as util from '../util';\r\nimport * as axis_util from './axis_util';\r\nimport { operation } from './operation';\r\nimport * as ops from './ops';\r\nvar NormOps = (function () {\r\n    function NormOps() {\r\n    }\r\n    NormOps.norm = function (x, ord, axis, keepDims) {\r\n        if (ord === void 0) { ord = 'euclidean'; }\r\n        if (axis === void 0) { axis = null; }\r\n        if (keepDims === void 0) { keepDims = false; }\r\n        util.assertArgumentsAreTensors({ x: x }, 'norm');\r\n        var norm = normImpl(x, ord, axis);\r\n        var keepDimsShape = norm.shape;\r\n        if (keepDims) {\r\n            var axes = axis_util.parseAxisParam(axis, x.shape);\r\n            keepDimsShape = axis_util.expandShapeToKeepDim(norm.shape, axes);\r\n        }\r\n        return norm.reshape(keepDimsShape);\r\n    };\r\n    tslib_1.__decorate([\r\n        doc({ heading: 'Operations', subheading: 'Matrices' }),\r\n        operation\r\n    ], NormOps, \"norm\", null);\r\n    return NormOps;\r\n}());\r\nexport { NormOps };\r\nfunction normImpl(x, p, axis) {\r\n    if (axis === void 0) { axis = null; }\r\n    if (x.rank === 0) {\r\n        return x.abs();\r\n    }\r\n    if (x.rank !== 1 && axis === null) {\r\n        return normImpl(x.reshape([-1]), p, axis);\r\n    }\r\n    if (x.rank === 1 || typeof axis === 'number' ||\r\n        axis instanceof Array && axis.length === 1) {\r\n        if (p === 1) {\r\n            return x.abs().sum(axis);\r\n        }\r\n        if (p === Infinity) {\r\n            return x.abs().max(axis);\r\n        }\r\n        if (p === -Infinity) {\r\n            return x.abs().min(axis);\r\n        }\r\n        if (p === 'euclidean' || p === 2) {\r\n            return x.abs().pow(ops.scalar(2, 'int32')).sum(axis).sqrt();\r\n        }\r\n        throw new Error(\"Error in norm: invalid ord value: \" + p);\r\n    }\r\n    if (axis instanceof Array && axis.length === 2) {\r\n        if (p === 1) {\r\n            return x.abs().sum(axis[0]).max(axis[1] - 1);\r\n        }\r\n        if (p === Infinity) {\r\n            return x.abs().sum(axis[1]).max(axis[0]);\r\n        }\r\n        if (p === -Infinity) {\r\n            return x.abs().sum(axis[1]).min(axis[0]);\r\n        }\r\n        if (p === 'fro' || p === 'euclidean') {\r\n            return x.square().sum(axis).sqrt();\r\n        }\r\n        throw new Error(\"Error in norm: invalid ord value: \" + p);\r\n    }\r\n    throw new Error(\"Error in norm: invalid axis: \" + axis);\r\n}\r\n//# sourceMappingURL=norm.js.map","map":"{\"version\":3,\"file\":\"norm.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/ops/norm.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/rollup/tfjs-core/ops/norm.d.ts","text":"import { Tensor } from '../tensor';\r\nexport declare class NormOps {\r\n    static norm(x: Tensor, ord?: number | 'euclidean' | 'fro', axis?: number | number[], keepDims?: boolean): Tensor;\r\n}\r\n"}}
